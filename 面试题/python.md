## 1.在python中，如何交换两个变量的值？
这个问题，考了python特殊的语法，也就是a, b = b, a，这个表达式，也是其他语言所没有的，是只有python自带的。

## 2. 字符串的拼接–如何高效的拼接两个字符串？
我们都知道python中，拼接字符串可以用”+”来拼接，然而这个方法并不是高效的，因为如果需要拼接的字符串有很多(n个)的情况下，使用”+”的话，python解释器会申请n-1次内存空间，然后进行拷贝，因为字符串在python中是不可变的，所以当进行拼接的时候，会需要申请一个新的内存空间。所以，正确答案是，使用.join(list),因为它只使用了一次内存空间。

## 3. list = [a,a,a,1,2,3,4,5,A,B,C]提取出”12345”
这个考点考了python的解压赋值的知识点，即 a,b,c,*middle, e,f,g = list, *middle = [1,2,3,4,5]。注意，解压赋值提取出来的是列表。

## 4. python中深浅拷贝的区别？
浅拷贝没有拷贝子对象，所以原对象发生改变，其子对象也发生了改变，而深拷贝拷贝了子对象，原对象发生改变，其本身也不会改变。具体的可以看我之前的博客python深浅copy一分钟掌握

## 5. 类的初始化：new() 和 init()?
new()方法用来实例化最终的类对象，在类创建之前被调用，它在类的主体被执行完后开始执行。
init()方法是在类被创建之后被调用，用来执行其他的一些输出化工作
当我们构造元类的时候，通常只需要定一个init()或new()方法，但不是两个都定义。但是，如果需要接受其他的关键词参数的话，这两个方法就要同时提供，并且都要提供对应的参数签名。

## 6.类的初始化？
B类继承A类，在B类自己的基础上可以调用A类所有方法，如果A,B同时拥有init， B会改写A中的init方法，A类的方法失效。
Super函数可以调用A类中的属性，B类中有同名属性时，覆盖A类中的同名属性。但调用函数时，总是先查找它自身的定义，如果没有定义，则顺着继承链向上插座，知道在某个父类中找到为止。
B类 init参数需大于或等于A 父类的init方法，因为super初始化了，参数量为父类参数量。

## 10.多线程？
多线程可以共享进程的内存空间，因此要实现多个线程之间的通信相对简单，比如设置一个全局变量，多个线程共享这个全局变量。但是当多个线程共享一个资源的时候，可能导致程序失效甚至崩溃，如果一个资源被多个线程竞争使用，那么对临界资源的访问需要加上保护，否则会处于“混乱”状态，比如银行存100块钱，最终很可能存不到一百块多个线程得到的余额状态都是0，所有操作都是在0上面加1，从而导致错误结果。这种情况下，锁就可以得到用处了。多线程并不能发挥cpu多核特性，因为python解释器有一个gil锁，任何线程执行前必须获得GIL锁，然后每执行100条字节码，解释器就会自动释放GIL锁让别的线程有机会执行。

## 11.python内存管理？
python内部使用引用计数，来保持追踪内存中的对象，Python内部记录了对象有多少个引用，即引用计数，当对象被创建时就创建了一个引用计数，当对象不再需要时，这个对象的引用计数为0时，它被垃圾回收。所有这些都是自动完成，不需要像C一样，人工干预，从而提高了程序员的效率和程序的健壮性。

## 12.python的filter方法？
filter就像map,reduce,apply,zip等都是内置函数，用C语言实现，具有速度快，功能强大等 优点。

## 13. 字符串的查询替换？
考点：python的find和replace函数。
给定一串字符串：

```python
string = 'life is short, I use python'
# 返回的为0或正数时，为其索引号
>>> string.find('life')
string.replace('short','long')
# replace 将short替换为long
>>> life is long, I use python

```

## 14.给定一串排好序的列表，打乱这个函数?
这个题考了python里的shuffle函数的用法。

```python
# random模块中的shuffle(洗牌函数)  
import random  
list = [1, 2, 3, 4]  
random.shuffle(list)     
print(list)
```
## 18. 实现一个斐波那契数列的生成器？
这道题的考点关键是生成器的yield关键字将一个普通函数改造成生成器函数：

```python
def fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
        yield a

def main():
    for val in fib(20):
        print(val)
if __name__ == '__main__':
    main()

```

